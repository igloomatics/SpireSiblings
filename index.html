<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¸¡ç…²å…„å¼Ÿ</title>
    <link rel="stylesheet" href="style.css">
    <script src="js/sound.js"></script>
    <script src="js/weapon.js"></script>
    <script src="js/relic.js"></script>
    <script src="js/enemy.js"></script>
</head>
<div id="tooltip" class="tooltip"></div>
<body>
<div id="gameContainer">

    <div id="topBanner">
        <div class="leftGroup">
            <span id="className">èŒä¸šåç§°</span>
            <span id="MoneyInfo">ğŸ’°<span id="coins">0</span></span>
        </div>

        <div id="waveInfo">
            ç¬¬ <span id="wave">1</span> å±‚ Â· <span id="waveTime">15</span>s
        </div>

        <span id="gameTime">â³<span id="time">0</span>s</span>
    </div>


    <!-- ç‹¬ç«‹è¡€æ¡ -->
    <div id="healthBarContainer">
        <div class="health-bar">
            <div class="health-bar-bg">
            <div class="health-bar-fill" id="healthFill"></div>
            </div>
            <span class="health-text" id="healthValue">20/20</span>
        </div>
    </div>

    <!-- ç»éªŒæ¡ -->
    <div id="expBarContainer">
        <div class="exp-bar">
            <div class="exp-bar-bg">
                <div class="exp-bar-fill" id="expFill"></div>
            </div>
            <div>Lv.</div><span class="exp-text" id="level">1</span>
        </div>
    </div>


    <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>ğŸ”¥ å¢ä¼¤ <span id="damageBonus">0</span>%</div>
            <div>ğŸ’ª åŠ›é‡ <span id="strength">0</span></div>
            <div>ğŸ¯ ç²¾å‡† <span id="precision">0</span></div>
            <div>ğŸ§  é›†ä¸­ <span id="focus">0</span></div>
            <div>ğŸƒ æ•æ· <span id="agility">0</span>%</div>
            <div>ğŸ’¨ æ”»é€Ÿ <span id="attackSpeed">1.0x</span></div>
            <div>ğŸ’¥ æš´å‡»ç‡ <span id="critRate">0</span>%</div>
            <div>ğŸ“¡ èŒƒå›´ <span id="scope">0</div>
            <div>ğŸ‘Ÿ ç§»é€Ÿ <span id="moveSpeed">3.0</span></div>
        </div>

        <div id="weapons">
            <strong>âš™ï¸ æ­¦å™¨:</strong>
            <div id="weaponsList" style="margin-top: 8px;"></div>
        </div>

        <div id="relics" style="
        position:absolute; top:180px; right:10px;
        font-size:12px; background:rgba(0,0,0,0.5);
        padding:10px 15px; border-radius:5px; border:1px solid #0f3460;
        max-width:200px; word-wrap:break-word;">
        <strong>ğŸº é—ç‰©:</strong>
        <div id="relicsList" style="margin-top:8px;"></div>
        </div>

        <div id="pauseHint">æŒ‰ ESC/P æš‚åœ</div>

        <div id="heroMenu">
        <h2>ğŸ§¬ é€‰æ‹©ä½ çš„è‹±é›„</h2>
        <p class="subtitle">'å“¦ï¼Œä½ æƒ³æˆä¸ºè°?'</p>
        <div class="heroOptions" id="heroOptions"></div>
        </div>


        <div id="blessingMenu">
            <div class="blessingContainer">
                <!-- å·¦ä¾§ï¼šè§’è‰²å›¾åƒ + é€‰é¡¹ -->
                <div class="blessingLeft">
                    <div class="blessingHeroImage">
                        <img id="blessingHeroImg" src="./image/jibao.png" ">
                    </div>
                    <div class="blessingOptionsContainer">
                        <div id="blessingOptions"></div>
                    </div>
                </div>
            </div>
        </div>



        <div id="levelUpMenu">
            <h2>ğŸ‰ å‡çº§ï¼</h2>
            <p>é€‰æ‹©ä¸€é¡¹å‡çº§ï¼š</p>
            <div class="upgradeOptions" id="upgradeOptions"></div>
        </div>

        <div id="shopMenu">
            <h2>ğŸª å°–å¡”å•†äºº ğŸª</h2>
            <div class="shopInfo">é‡‘å¸ x<span id="playerCoins">0</span></div>
            <div class="shopItems" id="shopItems"></div>
            <button class="shopCloseBtn" onclick="refreshShop()">åˆ·æ–°å•†å“ (5é‡‘å¸)</button>
            <button class="shopCloseBtn" onclick="closeShop()">å…³é—­å•†åº— (ç»§ç»­æ¸¸æˆ)</button>
        </div>

        <div id="pauseMenu">
            <h2>â¸ï¸ å·²æš‚åœ</h2>
            <button onclick="togglePause()">ç»§ç»­æ¸¸æˆ</button>
            <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>

        <div id="gameOver">
            <h1>ğŸ’€ æ¸¸æˆç»“æŸ</h1>
            <p>ç­‰çº§: <span id="finalLevel">1</span></p>
            <p>å‡»æ€: <span id="finalKills">0</span></p>
            <p>å­˜æ´»æ—¶é—´: <span id="finalTime">0</span>s</p>
            <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
<script>

(function () {
let shown = false;
window.addEventListener('error', (e) => {
if (!shown) {
    shown = true;
    alert('JS Error: ' + (e.message || e.error));
    console.error(e.error || e.message, e);
}
});
})();


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 900;
canvas.height = 600;


let gameRunning = false;
let gamePaused = false;
let frameCount = 0;
let gameTime = 0;
let kills = 0;
let level = 1;
let experience = 0;
let coins = 0; // åˆå§‹é‡‘å¸0
let experienceToLevel = 50;
let enemySpawnRate = 60;//åˆ·æ€ªé€Ÿåº¦
let baseEnemyHealth = 30;
let baseEnemyDamage = 5;
let baseEnemySpeed = 1;
let bossSpawned = false;   // æ£€æŸ¥ç¬¬10æ³¢æ˜¯å¦å·²ç”ŸæˆBossï¼ˆåªç”Ÿæˆä¸€æ¬¡ï¼‰
let bossDefeated = false;  // Bossæ˜¯å¦è¢«å‡»æ€ï¼ˆç¬¬10æ³¢ä¸ç«‹åˆ»é€šå…³ï¼Œåªåšæ ‡è®°ï¼‰


let currentWave = 1;
const maxWaves = 10;
const waveDurations = [15, 20, 25, 30, 40, 40, 40, 40, 40, 40]; // æ¯å±‚æŒç»­æ—¶é•¿
let waveTimer = waveDurations[0]; // å½“å‰æ³¢å€’è®¡æ—¶ï¼ˆå•ä½ï¼šç§’ï¼‰
let waveOngoing = true;
let shopRefreshCost = 5;


let particles = [];
// === ç»Ÿä¸€æµ®çƒè½¨é“è®¾ç½® ===
const FLOATING_ORBIT_RADIUS = 70;     // æ‰€æœ‰çƒä½¿ç”¨ç›¸åŒåŠå¾„ï¼ˆå¯æ”¹ï¼‰
const FLOATING_ORBIT_SPEED  = 0.08;   // é¸¡ç…²çš„çƒç»Ÿä¸€æ—‹è½¬é€Ÿåº¦
let floatingOrbitAngle = 0;           // å…¨å±€åŸºå‡†è§’
let meleeOrbitAngle = 0;             // æ—‹è½¬å‰‘çš„åŸºå‡†è§’
const MELEE_ROTATION_SPEED = 0.05; 

let damageNumbers = [];

// æ¯’åœˆæ•°ç»„
const poisonZones = [];

// ä¸­æ¯’æ•Œäººæ˜ å°„è¡¨ï¼ˆè®°å½•ä¸­æ¯’å¼€å§‹æ—¶é—´ï¼‰
const poisonedEnemies = new Map(); // key: enemyå¯¹è±¡, value: ä¸­æ¯’å¼€å§‹çš„å¸§æ•°


const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    skin: {
        name: 'è“çš®äºº',
        main: '#00d4ff',
        glowInner: 'rgba(0,212,255,0.8)',
        glowOuter: 'rgba(0,212,255,0)'
    },
    radius: 12,
    health: 20,
    maxHealth: 20,
    damageBonus: 0, // å¢ä¼¤ç™¾åˆ†æ¯”ï¼ˆå¦‚20è¡¨ç¤º+20%ï¼‰
    strength: 0,    // åŠ›é‡
    precision: 0,   // ç²¾å‡†
    focus: 0,       // é›†ä¸­
    agility: 0,     // æ•æ·ç™¾åˆ†æ¯”ï¼ˆå¦‚30è¡¨ç¤ºå‡å°‘30%ä¼¤å®³ï¼‰
    critRate: 1,    // æš´å‡»ç‡
    scope: 0, // èŒƒå›´
    attackSpeed: 1.0, // æ”»é€Ÿ
    baseSpeed: 3,    // ç§»é€Ÿ
    expBonus: 1, // ç»éªŒå€ç‡
    coinDropChance: 0.3,  // é»˜è®¤é‡‘å¸çˆ†ç‡
    speed: 3,
    weapons: [],
    relics: [],
    vx: 0,
    vy: 0
};




// æ ¹æ® key è£…å¤‡é—ç‰©ï¼šæ”¯æŒ uniqueï¼ˆæœ€å¤š1ä¸ªï¼‰å’Œ ordinaryï¼ˆå¯å åŠ ï¼‰
function equipRelicByKey(key) {
    const tpl = relicTypes[key];
    if (!tpl) return false;

    player.relics = player.relics || [];

    const category = tpl.category || 'ordinary';
    const existing = player.relics.find(r => r.key === key);

    // uniqueï¼šå·²æœ‰å°±ä¸å†æ·»åŠ 
    if (category === 'unique' && existing) {
        return false;
    }

    if (existing) {
        // ordinaryï¼šå å±‚å¹¶å†æ¬¡åº”ç”¨è¢«åŠ¨
        existing.stackCount = (existing.stackCount || 1) + 1;
        if (typeof tpl.applyOnPickup === 'function') tpl.applyOnPickup();
        return true;
    }

    // é¦–æ¬¡è·å¾—ï¼šå…¥èƒŒåŒ…å¹¶åº”ç”¨è¢«åŠ¨
    player.relics.push({
        key: key,
        name: tpl.name,
        desc: tpl.desc,
        lore: tpl.lore,
        rarity: tpl.rarity,
        category,
        stackCount: 1
    });
    if (typeof tpl.applyOnPickup === 'function') tpl.applyOnPickup();
    return true;
}


// å…‹éš†æ­¦å™¨æ¨¡æ¿å¹¶åˆå§‹åŒ–
function cloneWeaponByKey(key){
    const tpl = weaponTypes[key];
    if (!tpl) return null;
    const w = JSON.parse(JSON.stringify(tpl));
    w.lastFire = 0;  // å¼€ç«èŠ‚å¥è®¡æ•°å™¨
    w.angle = w.angle || 0;
    if (w.type === 'melee') {
        w.baseAngle = 0;
        w.radius = w.radius || 60;  // âœ… ç»™é»˜è®¤åŠå¾„
    }
    return w;
}


let enemies = [];
let bullets = [];
let drops = [];
let campfires = [];                 // åœºæ™¯ä¸­çš„ç«å †
const campfireRadius = 90;          // è§¦å‘èŒƒå›´åŠå¾„ï¼ˆåƒç´ ï¼‰
const campfireHealDelay = 2.0;      // åœç•™ç§’æ•°
const campfireSpawnInterval = 600;  // å°è¯•åˆ·æ–°çš„å¸§é—´éš”ï¼ˆçº¦10ç§’ï¼Œ60fpsï¼‰
const campfireSpawnChance = 0.35;   // æ¯æ¬¡å°è¯•ç”Ÿæˆçš„æ¦‚ç‡
const experienceColor = '#129c50';
const coinColor = '#ffff00';
const healthDropColor = '#ff69b4';
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
        togglePause();
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// === è‹±é›„çš®è‚¤åº“ ===
const HERO_SKINS = [
{
    key: 'red', name: 'çº¢çš®äºº',
    main: '#ff4d4d',
    glowInner: 'rgba(255,77,77,0.8)',
    glowOuter: 'rgba(255,77,77,0)',
    desc: 'éª¨å¼ ç¥­å¯äºº',
    weaponKey: 'sword1',
    relicKeys: ['BurningBlood'] 
},
{
    key: 'green', name: 'ç»¿çš®äºº',
    main: '#4dff88',
    glowInner: 'rgba(77,255,136,0.8)',
    glowOuter: 'rgba(77,255,136,0)',
    desc: 'è›Šç˜´æŠ€å¥‡äºº',
    weaponKey: 'bounceVial',
    relicKeys: ['RingOfTheSnake'] 
},
{
    key: 'blue', name: 'è“çš®äºº',
    main: '#00d4ff',
    glowInner: 'rgba(0,212,255,0.8)',
    glowOuter: 'rgba(0,212,255,0)',
    desc: 'æ•…éšœæœºå™¨äºº',
    weaponKey: 'frostBall',
    relicKeys: ['CrackedCore'] 
},
{
    key: 'purple', name: 'ç´«çš®äºº',
    main: '#9966ff',
    glowInner: 'rgba(153,102,255,0.8)',
    glowOuter: 'rgba(153,102,255,0)',
    desc: 'å­¤æ–è¿¹æ°”äºº',
    weaponKey: 'basicGun',
    relicKeys: ['PureWater'] 
}
];

// æ¸²æŸ“è‹±é›„é€‰æ‹©èœå•
function initHeroMenu(){
    const box = document.getElementById('heroOptions');
    box.innerHTML = '';
    HERO_SKINS.forEach(s => {
        const div = document.createElement('div');
        div.className = 'heroOption';
        div.innerHTML = `
        <div class="heroSwatch" style="color:${s.main}; background:${s.main}"></div>
        <div>
            <div style="font-weight:bold; font-size:14px;">${s.name}</div>
            <div class="heroMeta">${s.desc || 'ä¸€ä½ç¥ç§˜çš„å†’é™©è€…'}</div>
            <div class="heroMeta">åˆå§‹æ­¦å™¨ï¼š${(weaponTypes[s.weaponKey]?.name) || 'æ— '}</div>
        </div>
        `;
        div.onclick = () => chooseHero(s);
        box.appendChild(div);
    });
}

function chooseHero(skin){
    console.log('é€‰æ‹©è‹±é›„:', skin.name);
    
    player.skin = {
        name: skin.name,
        main: skin.main,
        glowInner: skin.glowInner,
        glowOuter: skin.glowOuter
    };
    
    // å…ˆå…³è‹±é›„é€‰æ‹©
    document.getElementById('heroMenu').style.display = 'none';
    document.getElementById('className').textContent = skin.name;

    // æ¸…ç©ºç°æœ‰æ­¦å™¨å’Œé—ç‰©
    player.weapons = [];
    player.relics = [];

    // è‡ªåŠ¨é…å¤‡åˆå§‹æ­¦å™¨
    if (skin.weaponKey){
        const starter = cloneWeaponByKey(skin.weaponKey);
        if (starter){
            starter.lastFire = 0;
            player.weapons.push(starter);
            console.log('æ·»åŠ åˆå§‹æ­¦å™¨:', starter.name);
        }
    }
    
    // è‡ªåŠ¨é…å¤‡åˆå§‹é—ç‰©
    if (Array.isArray(skin.relicKeys)) {
        skin.relicKeys.forEach(k => {
            console.log('æ·»åŠ åˆå§‹é—ç‰©:', k);
            equipRelicByKey(k);
        });
    }
    
    updateUI(); // ç«‹åˆ»åˆ·æ–°UI
    console.log('ç©å®¶æ­¦å™¨:', player.weapons);
    console.log('ç©å®¶é—ç‰©:', player.relics);

    // æ˜¾ç¤ºç¥ç¦èœå•
    showBlessingMenu(`./image/${skin.key}.png`);
    document.getElementById('blessingMenu').style.display = 'block';
    console.log('æ˜¾ç¤ºç¥ç¦èœå•');
}


const blessingOptions = [
    { 
        name: '[  è·å¾— 50é‡‘å¸  ]', 
        type: 'blessing',
        effects: () => {
            coins += 50;
        }
    },
    { 
        name: '[  æœ€å¤§ç”Ÿå‘½å€¼ +10  ]', 
        type: 'blessing',
        effects: () => {
            player.maxHealth += 10;
            player.health += 10;
        }
    },
];

// æ¯å›åˆç»“æŸåçš„æ•ˆæœæ¸…ç®—
function onWaveEndEffects() {
    // ç‡ƒçƒ§ä¹‹è¡€ï¼šæ³¢æ¬¡ç»“æŸå›è¡€ 10ï¼ˆå”¯ä¸€é—ç‰©ï¼Œä¸å åŠ ï¼‰
    if (player.relics && player.relics.some(r => r.key === 'BurningBlood')) {
        player.health = Math.min(player.maxHealth, player.health + 10);
        // å¯é€‰ï¼šé£˜ä¸ªç»¿è‰² +10ï¼ˆå¦‚æœä¸æƒ³é£˜å­—ï¼Œåˆ æ‰è¿™è¡Œï¼‰
        if (typeof createDamageNumber === 'function') {
            createDamageNumber(player.x, player.y - 22, +10, false);
        }
    }
}


// âœ… ä¸€é”®æ¸…åœºï¼šæ€ªç‰©ã€æ‰è½ã€å­å¼¹ï¼ˆå¯é€‰ç²’å­/ç«å †ï¼‰
function clearBattlefield(options = {}) {
    const { keepParticles = false, keepCampfires = false } = options;

    enemies.length = 0;   // æ¸…æ€ª
    drops.length = 0;     // æ¸…æ‰è½ï¼ˆé‡‘å¸/ç»éªŒ/å›è¡€åŒ…ç­‰ï¼‰
    bullets.length = 0;   // æ¸…å­å¼¹

    if (!keepCampfires) campfires.length = 0; // éœ€è¦çš„è¯ä¹Ÿæ¸…ç«å †
    if (!keepParticles) particles.length = 0; // éœ€è¦çš„è¯ä¹Ÿæ¸…ç²’å­æ•ˆæœ

    // å¦‚æœæœ‰ Boss æ ‡è®°ï¼ˆä½ ä¹‹å‰åŠ è¿‡ï¼‰ï¼Œåœ¨éç¬¬10æ³¢æˆ–è¿›å…¥ä¸‹ä¸€æ³¢æ—¶å¯é¡ºä¾¿å¤ä½
    if (typeof bossSpawned !== 'undefined') bossSpawned = false;
    if (typeof bossDefeated !== 'undefined') bossDefeated = false;
}


function showBlessingMenu(heroImageUrl) {
    const menu = document.getElementById('blessingMenu');
    const heroImg = document.getElementById('blessingHeroImg');
    const blessingOptionsDiv = document.getElementById('blessingOptions');
    
    // è®¾ç½®èƒŒæ™¯å›¾ç‰‡ - ä¿®å¤è·¯å¾„
    menu.style.backgroundImage = `./slaythespire.jpeg`;
    
    // è®¾ç½®è‹±é›„å½¢è±¡
    if (heroImg && heroImageUrl) heroImg.src = heroImageUrl;
    
    // åˆå§‹åŒ–é€‰é¡¹
    blessingOptionsDiv.innerHTML = '';
    
    blessingOptions.forEach((option, index) => {
        const div = document.createElement('div');
        div.className = 'blessingUpgradeOption';
        div.innerHTML = `
            <div style="flex: 1;">
                <h4>${option.name}</h4>
            </div>
        `;
        div.onclick = () => selectBlessing(option);
        blessingOptionsDiv.appendChild(div);
    });
    
    updateUI();
    
    // æ˜¾ç¤ºèœå•
    menu.style.display = 'flex';
}

function selectBlessing(blessing) {
    const selectedOptions = document.querySelectorAll('.blessingUpgradeOption');
    selectedOptions.forEach(opt => opt.classList.remove('selected'));
    
    // è·å–ç‚¹å‡»çš„é€‰é¡¹å¹¶æ·»åŠ selectedç±»
    event.currentTarget.classList.add('selected');
    
    // å»¶è¿Ÿæ‰§è¡Œæ•ˆæœï¼Œè®©ç”¨æˆ·çœ‹åˆ°é€‰ä¸­çŠ¶æ€
    setTimeout(() => {
        blessing.effects();
        document.getElementById('blessingMenu').style.display = 'none';
        gameRunning = true;
        updateUI();
        gameLoop();
    }, 300);
}



function createDamageNumber(x, y, damage, isCrit = false, style = null) {
    damageNumbers.push({
        x: x,
        y: y,
        damage: Math.ceil(damage),
        life: 60,
        maxLife: 60,
        isCrit: isCrit,
        style: style,            // æ–°å¢ï¼šæ ·å¼æ ‡è®°ï¼ˆ'playerHurt' ç”¨äºç©å®¶å—ä¼¤ï¼‰
        vx: (Math.random() - 0.5) * 2,
        vy: -2
    });
}


function updateDamageNumbers() {
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
        const num = damageNumbers[i];
        num.life--;
        num.x += num.vx;
        num.y += num.vy;
        num.vy += 0.05;

        if (num.life <= 0) {
            damageNumbers.splice(i, 1);
        }
    }
}

function drawDamageNumbers() {
    damageNumbers.forEach(num => {
        const alpha = num.life / num.maxLife;
        ctx.globalAlpha = alpha;

        // é¢œè‰²ä¸æ ·å¼
        let fill = '#ffffff';
        let font = 'bold 16px Arial';
        if (num.isCrit) {
            fill = '#ffd700';            // æš´å‡»æ”¹ä¸ºé»„è‰²
            font = 'bold 20px Arial';
        } else if (num.style === 'playerHurt') {
            fill = '#ff0000';            // ç©å®¶å—ä¼¤æ˜¾ç¤ºçº¢è‰²
            font = 'bold 18px Arial';
        } else if (num.style === 'poisoned'){
            fill = '#66ff33';            // ä¸­æ¯’æ˜¾ç¤ºç»¿è‰²
            font = 'bold 16px Arial';
        }

        ctx.fillStyle = fill;
        ctx.font = font;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(num.damage, num.x, num.y);
        ctx.fillText(num.damage, num.x, num.y);

        ctx.globalAlpha = 1;
    });
}


function calculateDamage(baseDamage,weaponType = null) {
    const isCrit = Math.random() * 100 < player.critRate;
    // åº”ç”¨å¢ä¼¤ç™¾åˆ†æ¯”
        const critMultipliers = {
            knife: 3.0,       // å°åˆ€æš´å‡» 3 å€
            shotgun: 2.0,     // éœ°å¼¹æª 2.5 å€
            laser: 1.5,       // æ¿€å…‰æª 1.5 å€
            sword1: 2.0,      // æ—‹è½¬å‰‘ 2.2 å€
            lightningBall: 2.0, // é—ªç”µçƒæ™®é€š 2 å€
            frostBall: 2.0,
            shadowBall: 2.0,
            basicGun: 2.0,     // é»˜è®¤ 2 å€
            poisonVial: 1.0
        };
    let finalDamage = baseDamage * (1 + player.damageBonus / 100);
    if (isCrit) {
        const multiplier = critMultipliers[weaponType] || 2.0; // è‹¥æ— å®šä¹‰ï¼Œé»˜è®¤2å€
        finalDamage *= multiplier;
    }
    return { damage: finalDamage, isCrit: isCrit };
}


function createLightningEffect(x1, y1, x2, y2) {
    playLightningSound();
    
    const segments = 8;
    const points = [];
    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const x = x1 + (x2 - x1) * t;
        const y = y1 + (y2 - y1) * t;
        const offsetX = (Math.random() - 0.5) * 20;
        const offsetY = (Math.random() - 0.5) * 20;
        points.push({ x: x + offsetX, y: y + offsetY });
    }
    
    particles.push({
        type: 'lightning',
        points: points,
        life: 15,
        maxLife: 15,
        color: '#ffff00'
    });

    for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
            type: 'spark',
            x: x2,
            y: y2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 20,
            maxLife: 20,
            size: 2 + Math.random() * 2,
            color: '#ffff00'
        });
    }
}

function createKillEffect(x, y, color) {
    for (let i = 0; i < 15; i++) {
        const angle = (Math.PI * 2 * i) / 15;
        const speed = 2 + Math.random() * 3;
        particles.push({
            type: 'explosion',
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 30,
            maxLife: 30,
            size: 3 + Math.random() * 3,
            color: color
        });
    }
}

function createPickupEffect(x, y, color) {
    for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const speed = 1 + Math.random() * 2;
        particles.push({
            type: 'sparkle',
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            life: 25,
            maxLife: 25,
            size: 2 + Math.random() * 2,
            color: color
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.life--;

        if (particle.life <= 0) {
            particles.splice(i, 1);
            continue;
        }

        if (particle.type === 'spark' || particle.type === 'explosion' || particle.type === 'sparkle') {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.1;
        }
    }
}

function drawParticles() {
    particles.forEach(particle => {
        const alpha = particle.life / particle.maxLife;
        
        if (particle.type === 'lightning') {
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = particle.color;
            ctx.lineWidth = 3;
            ctx.shadowColor =
            particle.color;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.moveTo(particle.points[0].x, particle.points[0].y);
            for (let i = 1; i < particle.points.length; i++) {
                ctx.lineTo(particle.points[i].x, particle.points[i].y);
            }
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        } else {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = particle.color;
            ctx.shadowColor = particle.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }
    });
}

function drawPlayer(x, y) {
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, player.radius + 5);
    gradient.addColorStop(0, player.skin.glowInner);  // åŸæ¥æ˜¯ rgba(0,212,255,0.8)
    gradient.addColorStop(1, player.skin.glowOuter);  // åŸæ¥æ˜¯ rgba(0,212,255,0)
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, player.radius + 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = player.skin.main;                 // åŸæ¥æ˜¯ #00d4ff
    ctx.beginPath();
    ctx.arc(x, y, player.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';       // é«˜å…‰ä¿ç•™
    ctx.beginPath();
    ctx.arc(x - 3, y - 3, player.radius * 0.4, 0, Math.PI * 2);
    ctx.fill();
}


function drawLightningBall(weapon, x, y) {
    ctx.fillStyle = weapon.color;
    ctx.shadowColor = weapon.color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.8;
    for (let i = 0; i < 4; i++) {
        const angle = (Math.random() - 0.5) * Math.PI;
        const len = 10 + Math.random() * 6;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

function drawFrostBall(weapon, x, y) {
    ctx.fillStyle = weapon.color;
    ctx.shadowColor = weapon.color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 + frameCount * 0.02;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
        ctx.stroke();
    }
    // è¿½åŠ ï¼šå†°é›¾å‘¼å¸è¾¹ç¼˜
    ctx.globalAlpha = 0.6 + 0.3 * Math.sin(frameCount * 0.1);
    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(x, y, 12 + Math.sin(frameCount * 0.12) * 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;

}

function drawShadowBall(weapon, x, y) {
    ctx.fillStyle = weapon.color;
    ctx.shadowColor = weapon.color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(x, y, 12 + Math.sin(frameCount * 0.1) * 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // è¿½åŠ ï¼šé€æ¸æ‰©æ•£çš„æš—å½±æ¶Ÿæ¼ª
    const rippleR = 10 + (frameCount % 30) * 0.8;
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y, rippleR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // è¿½åŠ ï¼šæŠ–åŠ¨è§¦é¡»
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = weapon.color;
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
    const a = i * (Math.PI * 2 / 8) + frameCount * 0.05;
    const len = 10 + Math.sin(frameCount * 0.15 + i) * 3;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(a) * len, y + Math.sin(a) * len);
    ctx.stroke();
}
ctx.globalAlpha = 1;

}

function drawKnifeProjectile(b) {
    const stroke = '#2b2b2b';        // æ·±ç°æè¾¹
    const bladeFill = '#cfcfcf';     // åˆƒï¼šæµ…ç°
    const handleFill = '#5e3b2e';    // æ‰‹æŸ„ï¼šæ£•

    const L = b.bladeLen || 22;
    const W = b.bladeWidth || 7;
    const tipL = b.tipLen || 8;
    const hL = b.handleLen || 10;
    const hW = b.handleWidth || 6;

    // å°åˆ€å‡ ä½•ï¼šä»¥ (b.x,b.y) ä¸ºä¸­å¿ƒç¨å¾®é åï¼Œä½¿åˆ€å°–åœ¨å‰
    // è®©åˆ€å°–å¤§çº¦ä½äºå¼¹ä½“ä¸­å¿ƒåå‰ 1/3 å¤„ï¼Œç›´è§‰æ›´åƒâ€œé£åˆ€â€
    const offset = L * 0.35;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(Math.atan2(b.vy, b.vx)); // æŒ‰é€Ÿåº¦æ–¹å‘æœå‰

    // æ‰‹æŸ„ï¼ˆåœ¨åä¾§ï¼‰
    ctx.fillStyle = handleFill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-offset - hL, -hW / 2, hL, hW);
    ctx.fill();
    ctx.stroke();

    // åˆƒï¼šçŸ©å½¢ + ä¸‰è§’å°–ï¼ˆæœå‰ï¼‰
    ctx.fillStyle = bladeFill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    // çŸ©å½¢æ®µ
    ctx.moveTo(-offset, -W / 2);
    ctx.lineTo(L - tipL - offset, -W / 2);
    // ä¸‰è§’å°–
    ctx.lineTo(L - offset, 0);
    ctx.lineTo(L - tipL - offset, W / 2);
    // å›åˆ°çŸ©å½¢åº•è¾¹
    ctx.lineTo(-offset, W / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // ç®€å•é«˜å…‰ï¼ˆå·¦ä¾§ä¸€ç‚¹ç‚¹ï¼‰
    const grad = ctx.createLinearGradient(-offset - 2, 0, L - offset, 0);
    grad.addColorStop(0.0, 'rgba(255,255,255,0.25)');
    grad.addColorStop(0.3, 'rgba(255,255,255,0.06)');
    grad.addColorStop(1.0, 'rgba(255,255,255,0.00)');
    ctx.fillStyle = grad;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillRect(-offset, -W / 2, L, W);
    ctx.globalCompositeOperation = 'source-over';

    ctx.restore();
}


function drawSword(x, y, angle, weapon) {
    // æ¥æ”¶å·²è®¡ç®—å¥½çš„å‰‘çš„ä½ç½® (x,y) å’Œæœå‘ angle
    const L = weapon.radius - 5;  // âœ… å…œåº•é»˜è®¤å€¼
    const W = 10, tipL = 12, guardW = 14, guardH = 6, handleL = 12, handleW = 6;

    ctx.save();
    ctx.translate(x, y);        // âœ… å¹³ç§»åˆ°å‰‘çš„ä½ç½®ï¼ˆä¸æ˜¯ç©å®¶ä¸­å¿ƒï¼‰
    ctx.rotate(angle);          // âœ… æ—‹è½¬åˆ°å‰‘çš„æœå‘

    // æŠ¤æ‰‹
    ctx.fillStyle = '#9a9a9a';
    ctx.strokeStyle = '#2b2b2b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-guardW/2, -guardH/2, guardW, guardH);
    ctx.fill();
    ctx.stroke();

    // æ¡æŸ„
    ctx.fillStyle = '#5e3b2e';
    ctx.beginPath();
    ctx.rect(-(guardW/2) - handleL, -handleW/2, handleL, handleW);
    ctx.fill();
    ctx.stroke();

    // å‰‘èº«
    ctx.fillStyle = '#cfcfcf';
    ctx.beginPath();
    ctx.moveTo(0, -W/2);
    ctx.lineTo(L - tipL, -W/2);
    ctx.lineTo(L, 0);
    ctx.lineTo(L - tipL, W/2);
    ctx.lineTo(0, W/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.restore();
}




// éšæœºç”Ÿæˆä¸€ä¸ªç«å †ï¼ˆä¸è´´è¾¹ï¼‰
function spawnCampfire() {
    if (campfires.length > 3) return;
    const padding = 80;
    const x = padding + Math.random() * (canvas.width - padding * 2);
    const y = padding + Math.random() * (canvas.height - padding * 2);

    campfires.push({
        x, y,
        radius: campfireRadius,
        // ç©å®¶æ˜¯å¦åœ¨èŒƒå›´å†…çš„åœç•™è®¡æ—¶ï¼ˆç§’ï¼‰
        stayTimer: 0,
        // ä¸€ä¸ªç®€å•çš„åŠ¨ç”»ç”¨è§’åº¦
        t: Math.random() * Math.PI * 2,
        // æ˜¯å¦å·²ç»è§¦å‘è¿‡æ²»ç–—ï¼ˆè§¦å‘ä¸€æ¬¡å°±é”€æ¯ï¼‰
        consumed: false,
        health: 50,
        maxHealth: 50,
        hitRadius: 16, // ç”¨äºå­å¼¹/è¿‘æˆ˜ç¢°æ’
    });
}

// æ›´æ–°ç«å †ï¼ˆåˆ¤å®šç©å®¶åœç•™2så¹¶æ²»ç–—ï¼‰
function updateCampfires(dt) {
    for (let i = campfires.length - 1; i >= 0; i--) {
        const f = campfires[i];
        f.t += dt * 3; // ä»…ä½œå°å¹…åŠ¨ç”»
        // ï¼ˆè¿™é‡Œä¸å†åšåœç•™å›è¡€åˆ¤å®šï¼‰
        // å¦‚æœä»¥åè¦åŠ å…¶å®ƒè¡Œä¸ºï¼Œå¯åœ¨æ­¤æ‰©å±•
    }
}
          
function updatePoisonZones() {
    // æ›´æ–°æ¯’åœˆ
    for (let i = poisonZones.length - 1; i >= 0; i--) {
        const zone = poisonZones[i];
        
        // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if (frameCount - zone.createdAt > zone.duration) {
            poisonZones.splice(i, 1);
            continue;
        }
        
        // æ£€æµ‹æ•Œäººæ˜¯å¦åœ¨æ¯’åœˆå†…
        enemies.forEach(enemy => {
            const dist = Math.hypot(enemy.x - zone.x, enemy.y - zone.y);
            if (dist < zone.radius + enemy.radius) {
                // æ ‡è®°æ•Œäººä¸ºä¸­æ¯’çŠ¶æ€
                if (!poisonedEnemies.has(enemy)) {
                    poisonedEnemies.set(enemy, frameCount);
                }
            }
        });
    }
    
    // æ›´æ–°ä¸­æ¯’æ•Œäºº
    poisonedEnemies.forEach((startFrame, enemy) => {
        const elapsedFrames = frameCount - startFrame;
        
        // æ¯50å¸§ï¼ˆ5/6ç§’ï¼‰é€ æˆ6ç‚¹ä¼¤å®³
        if (elapsedFrames % 50 === 0 && elapsedFrames > 0) {
            const basePoisonDamage = 6;
            // åŠ ä¸Šç©å®¶åŠ æˆï¼ˆå¯ä»¥å’Œæ™®é€šæ”»å‡»é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
            const totalPoisonDamage = basePoisonDamage * (1 + player.damageBonus / 100);
            // è®¡ç®—ç»“æœï¼ˆå¸¦æš´å‡»æˆ–æŠ€èƒ½è§¦å‘é€»è¾‘ï¼‰
            const result = calculateDamage(totalPoisonDamage, 'poisonVial');
            enemy.health -= result.damage;
            createDamageNumber(enemy.x, enemy.y - 10, result.damage, false, 'poisoned');
        }
        
        // 5ç§’åç§»é™¤ä¸­æ¯’çŠ¶æ€ï¼ˆ300å¸§ï¼‰
        if (elapsedFrames > 300) {
            poisonedEnemies.delete(enemy);
        }
    });
    
    // æ¸…ç†å·²æ­»äº¡çš„æ•Œäºº
    const deadEnemies = Array.from(poisonedEnemies.keys()).filter(e => 
        !enemies.includes(e)
    );
    deadEnemies.forEach(e => poisonedEnemies.delete(e));
}

function drawPoisonZones() {
    poisonZones.forEach(zone => {
        const age = frameCount - zone.createdAt;
        const opacity = 1 - (age / zone.duration); // é€æ¸æ¶ˆå¤±
        
        ctx.save();
        ctx.globalAlpha = opacity * 0.4;
        
        // ç»˜åˆ¶æ¯’åœˆ
        ctx.fillStyle = '#498e24';
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // å¤–åœˆè¾¹ç•Œ
        ctx.strokeStyle = '#498e24';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
    });
}


// ç»˜åˆ¶ç«å †
function drawCampfires() {
    campfires.forEach(f => {
        // åœ°é¢å…‰åœˆ
        const grad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.radius);
        grad.addColorStop(0, 'rgba(255, 149, 0, 0.10)');
        grad.addColorStop(1, 'rgba(255, 149, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
        ctx.fill();

        // ç«ç„°ä¸»ä½“ï¼ˆç®€å•è·³åŠ¨ï¼‰
        const flameR = 10 + Math.sin(f.t) * 2;
        ctx.fillStyle = '#ff922b';
        ctx.shadowColor = '#ff922b';
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(f.x, f.y - 6, flameR, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // âœ… ç«å †è¡€æ¡
        const barW = 26, barH = 4;
        ctx.fillStyle = 'red';
        ctx.fillRect(f.x - barW/2, f.y - 22, barW, barH);
        ctx.fillStyle = 'lime';
        ctx.fillRect(f.x - barW/2, f.y - 22, barW * (f.health / f.maxHealth), barH);
    });
}


function updateDrops() {
    for (let i = drops.length - 1; i >= 0; i--) {
        const drop = drops[i];
        const dx = player.x - drop.x;
        const dy = player.y - drop.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 120) {
            const speed = 8;
            drop.x += (dx / dist) * speed;
            drop.y += (dy / dist) * speed;
        }

        if (dist < 25) {
            playPickupSound();
            createPickupEffect(drop.x, drop.y, drop.color);
            
            if (drop.type === 'experience') {
                experience += drop.value;
            } else if (drop.type === 'coin') {
                coins += drop.value;
            } else if (drop.type === 'health') {
                player.health = Math.min(player.maxHealth, player.health + drop.value);
            }
            drops.splice(i, 1);
            continue;
        }
    }

    if (experience >= experienceToLevel) {
        levelUp();
        player.maxHealth += 5;
        player.health += 5;
    }
}

const upgradePool = [
    { name: 'æœ€å¤§ç”Ÿå‘½å€¼ +12', type: 'health', value: 12, desc: 'å¢åŠ æœ€å¤§ç”Ÿå‘½å€¼å¹¶å›å¤' },
    { name: 'æ”»é€Ÿ +0.1x', type: 'attackSpeed', value: 0.1, desc: 'æå‡æ”»å‡»é€Ÿåº¦' },
    { name: 'ç§»é€Ÿ +0.5', type: 'speed', value: 0.5, desc: 'æå‡ç§»åŠ¨é€Ÿåº¦' },
    { name: 'æš´å‡»ç‡ +8%', type: 'critRate', value: 8, desc: 'æå‡æš´å‡»å‡ ç‡ï¼Œæš´å‡»é€ æˆ2å€ä¼¤å®³' },
    { name: 'å¢ä¼¤ +8%', type: 'damageBonus', value: 8, desc: 'æ‰€æœ‰ä¼¤å®³ +8%' },
    { name: 'åŠ›é‡ +6', type: 'strength', value: 6, desc: 'è¿‘æˆ˜æ­¦å™¨ +6 ä¼¤å®³' },
    { name: 'ç²¾å‡† +4', type: 'precision', value: 4, desc: 'è¿œç¨‹æ­¦å™¨ +4 ä¼¤å®³' },
    { name: 'é›†ä¸­ +5', type: 'focus', value: 5, desc: 'æµ®çƒæ­¦å™¨ +5 ä¼¤å®³' },
    { name: 'æ•æ· +5%', type: 'agility', value: 5, desc: 'å‡å°‘5%æ‰¿å—ä¼¤å®³' },

];

function levelUp() {
    gamePaused = true;
    experience -= experienceToLevel;
    level++;
    experienceToLevel = Math.floor(experienceToLevel * 1.3);

    const options = [];
    const poolCopy = [...upgradePool];
    
    for (let i = 0; i < 4 && poolCopy.length > 0; i++) {
        const index = Math.floor(Math.random() * poolCopy.length);
        options.push(poolCopy[index]);
        poolCopy.splice(index, 1);
    }

    const upgradeOptionsDiv = document.getElementById('upgradeOptions');
    upgradeOptionsDiv.innerHTML = '';
    
    options.forEach((option, index) => {
        const div = document.createElement('div');
        div.className = 'upgradeOption';
        div.innerHTML = `
            <div class="upgradeNumber">${index + 1}</div>
            <div class="upgradeContent">
                <h3>${option.name}</h3>
                <p>${option.desc}</p>
            </div>
        `;
        div.onclick = () => selectUpgrade(option);
        upgradeOptionsDiv.appendChild(div);
    });

    document.getElementById('levelUpMenu').style.display = 'block';
}

function selectUpgrade(option) {
    if (option.type === 'health') {
        player.maxHealth += option.value;
        player.health += option.value;
    } else if (option.type === 'attackSpeed') {
        player.attackSpeed += option.value;
    } else if (option.type === 'speed') {
        player.baseSpeed += option.value;
        player.speed = player.baseSpeed;
    } else if (option.type === 'critRate') {
        player.critRate = Math.min(100, player.critRate + option.value);
    }else if (option.type === 'damageBonus') {
        player.damageBonus += option.value;
    } else if (option.type === 'strength') {
        player.strength += option.value;
    } else if (option.type === 'precision') {
        player.precision += option.value;
    } else if (option.type === 'focus') {
        player.focus += option.value;
    } else if (option.type === 'agility') {
        player.agility += option.value;
    }
    document.getElementById('levelUpMenu').style.display = 'none';
    gamePaused = false;
    updateUI();
}

function pickItemByRarity(items, rarityWeights) {
    // åŠ¨æ€æƒé‡ï¼ˆéšç­‰çº§å˜åŒ–ï¼‰

    // æŒ‰ç¨€æœ‰åº¦åˆ†ç»„
    const pools = {
        common: items.filter(i => i.rarity === 'common'),
        rare: items.filter(i => i.rarity === 'rare'),
        legendary: items.filter(i => i.rarity === 'legendary')
    };

    // éšæœºæŠ½å–ç¨€æœ‰åº¦
    const total = rarityWeights.common + rarityWeights.rare + rarityWeights.legendary;
    let rand = Math.random() * 100;


    let chosenPool;
    if (rand < rarityWeights.legendary) {
        chosenPool = pools.legendary;
    } else if (rand < rarityWeights.legendary + rarityWeights.rare) {
        chosenPool = pools.rare;
    } else {
        chosenPool = pools.common;
    }

    

    // å¦‚æœè¯¥ç¨€æœ‰åº¦æ²¡æœ‰ç‰©å“ï¼Œé™çº§å¤„ç†
    if (chosenPool.length === 0) {
        // å°è¯•é™çº§ï¼šä¼ è¯´ â†’ ç¨€æœ‰ â†’ æ™®é€š
        if (pools.rare.length > 0) chosenPool = pools.rare;
        else if (pools.common.length > 0) chosenPool = pools.common;
        else return items[0]; // ä¿åº•
    }

    // ä»æ± å­é‡Œéšæœºé€‰ä¸€ä¸ª
    return chosenPool[Math.floor(Math.random() * chosenPool.length)];
}


function generateShopItems() {
    const shopItems = [];
    const itemKeys = Object.keys(weaponTypes);  // è·å–æ­¦å™¨ç±»å‹é”®å
    const relicKeys = Object.keys(relicTypes).filter(k => relicTypes[k].shopAvailable !== false);
// è·å–é—ç‰©ç±»å‹é”®åï¼Œä¸å‡ºå”®ç‰¹å®šé—ç‰©


    const rarityWeights = {
        common: 80 - level,
        rare: 15 + 0.7 * level,
        legendary: 5 + 0.3 * level
    };
    

    let priceMultiplier = 1;
    if (currentWave >= 1 && currentWave <= 2) priceMultiplier = 0.5;
    else if (currentWave >= 3 && currentWave <= 5) priceMultiplier = 0.8;
    else if (currentWave >= 6 && currentWave <= 7) priceMultiplier = 1.0;
    else if (currentWave >= 8 && currentWave <= 9) priceMultiplier = 1.5;
    else if (currentWave >= 10) priceMultiplier = 1.5; // æˆ–è€…è‡ªå®šä¹‰


    for (let i = 0; i < 4; i++) {
        let isRelic = Math.random() < 0.5;  // 50% æ¦‚ç‡ç”Ÿæˆé—ç‰©
        let item, key, rarity;

        if (isRelic) {
            const availableRelics = relicKeys.map(k => ({
                key: k,
                ...relicTypes[k]
            }));
            item = pickItemByRarity(availableRelics, rarityWeights);
            key = item.key;
            rarity = item.rarity || 'common';
        } else {
            // ===== æŠ½å–æ­¦å™¨ =====
            const availableWeapons = itemKeys.map(k => ({
                key: k,
                ...weaponTypes[k]
            }));
            item = pickItemByRarity(availableWeapons, rarityWeights);
            key = item.key;
            rarity = item.rarity || 'common';
        }

        const finalCost = Math.round(item.cost * priceMultiplier);

        shopItems.push({
            ...item,
            key,
            rarity,
            cost: finalCost,
            isRelic
        });
    }

    return shopItems;  // è¿”å›å•†å“æ•°ç»„
}

// ===== Tooltip æ ¸å¿ƒ =====
const tooltipEl = document.getElementById('tooltip');
let tooltipVisible = false;

function showTooltip(html) {
    tooltipEl.innerHTML = html;
    tooltipEl.style.display = 'block';
    tooltipVisible = true;
}
function hideTooltip() {
    tooltipEl.style.display = 'none';
    tooltipVisible = false;
}
document.addEventListener('mousemove', (e) => {
    if (!tooltipVisible) return;
    const pad = 12;
    const vw = window.innerWidth, vh = window.innerHeight;
    const left = Math.min(e.clientX + pad, vw - tooltipEl.offsetWidth - 8);
    const top  = Math.min(e.clientY + pad, vh - tooltipEl.offsetHeight - 8);
    tooltipEl.style.left = left + 'px';
    tooltipEl.style.top  = top + 'px';
});

function esc(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function fmtWeaponTip(w){
    const typeMap = { melee:'è¿‘æˆ˜', ranged:'è¿œç¨‹', floating:'æµ®çƒ' };
    const rows = [];
    rows.push(`<h4>${esc(w.name||'æ­¦å™¨')}</h4>`);
    rows.push(`<div class="muted">${esc(w.desc || 'ä¸€ä»¶è¶æ‰‹çš„æ­¦å™¨')}</div>`);
    rows.push(`<div class="tag">ç±»å‹ï¼š${esc(typeMap[w.type]||w.type||'æœªçŸ¥')}ã€€ç¨€æœ‰åº¦ï¼š${esc(w.rarity||'common')}</div>`);
    if (w.damage!=null) rows.push(`ä¼¤å®³ï¼š<span class="num">${esc(w.damage)}</span>`);
    if (w.fireRate!=null) rows.push(`æ”»é€Ÿå‘¨æœŸï¼š<span class="num">${esc(w.fireRate)}</span> å¸§`);
    if (w.range!=null) rows.push(`å°„ç¨‹ï¼š<span class="num">${esc(w.range)}</span>`);
    if (w.pierce!=null) rows.push(`ç©¿é€ï¼š<span class="num">${esc(w.pierce)}</span>`);
    if (w.radius!=null && w.type==='melee') rows.push(`åŠå¾„ï¼š<span class="num">${esc(w.radius)}</span>`);
    if (w.floatingRadius!=null && w.type==='floating') rows.push(`è½¨é“åŠå¾„ï¼š<span class="num">${esc(w.floatingRadius)}</span>`);
    return rows.join('<br>');
}
function fmtRelicTip(r){
    const rows = [];
    const tag = (r.category==='unique') ? 'å”¯ä¸€' : 'æ™®é€š';
    const stack = r.stackCount && r.stackCount>1 ? ` Ã—${r.stackCount}` : '';
    rows.push(`<h4>${esc(r.name||'é—ç‰©')}</h4>`);
    rows.push(`<div class="muted">${esc(r.desc || r.lore || 'ç¥ç§˜çš„é—ç‰©')}</div>`);
    rows.push(`<div class="tag">ç±»å‹ï¼š${tag}${stack}ã€€ç¨€æœ‰åº¦ï¼š${esc(r.rarity || 'common')}</div>`);
    return rows.join('<br>');
}

// äº‹ä»¶å§”æ‰˜ï¼ˆç»™å®¹å™¨åªç»‘å®šä¸€æ¬¡ï¼‰
function bindTooltipDelegation(container){
    if (!container || container.__tooltipBound) return;
    container.addEventListener('mouseover', (e) => {
        const t = e.target.closest('[data-tip-html]');
        if (!t || !container.contains(t)) return;
        showTooltip(t.getAttribute('data-tip-html'));
    });
    container.addEventListener('mouseout', (e) => {
        const t = e.target.closest('[data-tip-html]');
        const rel = e.relatedTarget;
        if (t && (!rel || !t.contains(rel))) hideTooltip();
    });
    container.__tooltipBound = true;
}



function openShop() {
    gamePaused = true;
    document.getElementById('pauseMenu').style.display = 'none';
    document.getElementById('shopMenu').style.display = 'block';

    // æ¯æ¬¡æ‰“å¼€éƒ½åˆ·æ–°å•†å“ï¼ˆä»ç”Ÿæˆå‡½æ•°è·å–ï¼‰
    const shopItems = generateShopItems();  // è·å–ç”Ÿæˆçš„å•†å“åˆ—è¡¨
    const shopItemsDiv = document.getElementById('shopItems');
    shopItemsDiv.innerHTML = '';  // æ¸…ç©ºå½“å‰çš„å•†å“å±•ç¤ºå†…å®¹

    // æ›´æ–°é‡‘å¸æ•°ç›®
    document.getElementById('playerCoins').textContent = coins;

    // æ¸²æŸ“å•†åº—ç‰©å“
    shopItems.forEach((item) => {
        const div = document.createElement('div');
        div.className = `shopItem ${item.rarity}`;

        let rarityText = 'æ™®é€š';
        if (item.rarity === 'rare') rarityText = 'ç¨€æœ‰ (è“)';
        if (item.rarity === 'legendary') rarityText = 'ä¼ è¯´ (é‡‘)';

        div.innerHTML = `
            <h3>${item.name}${item.isRelic ? 'ï¼ˆé—ç‰©ï¼‰' : ''}</h3>
            <p>${item.desc || (item.isRelic ? 'ç¥ç§˜çš„é—ç‰©' : 'ä¸€ç§æœ‰ç”¨çš„æ­¦å™¨')}</p>
            ${item.lore ? `<p class="lore">${item.lore}</p>` : ''}
            <div class="price">ä»·æ ¼ï¼š${item.cost} é‡‘å¸</div>
            <div class="rarity">ç¨€æœ‰åº¦ï¼š${rarityText}</div>
        `;

        // ä½™é¢ä¸è¶³æ—¶ç¦ç”¨ç‚¹å‡»å’Œæ”¹å˜æ ·å¼
        if (coins < item.cost) {
            div.style.opacity = '0.6';
            div.style.filter = 'grayscale(30%)';
            div.style.cursor = 'not-allowed';
        }

        // ç‚¹å‡»è´­ä¹°å•†å“
        div.onclick = () => {
            if (coins < item.cost) {
                alert('ä½ çš„é’±ä¸å¤Ÿå•Šï¼');
                return;
            }
            buyItem(item);  // è°ƒç”¨è´­ä¹°å‡½æ•°
        };
        shopItemsDiv.appendChild(div);  // å°†å•†å“æ¸²æŸ“åˆ°é¡µé¢ä¸Š
    });
}

function buyItem(item) {
    if (coins >= item.cost) {
        coins -= item.cost;
        playPickupSound();
        document.getElementById('playerCoins').textContent = coins;

        if (item.isRelic) {
            // ğŸ è´­ä¹°é—ç‰©
            const relic = relicTypes[item.key];
            if (relic && relic.applyOnPickup) relic.applyOnPickup();

            player.relics.push({
                key: item.key,
                name: item.name,
                desc: item.desc,
                rarity: item.rarity
            });
        } else {
            // ğŸ”« è´­ä¹°æ­¦å™¨
            const newWeapon = JSON.parse(JSON.stringify(weaponTypes[item.key]));
            newWeapon.lastFire = 0;
            player.weapons.push(newWeapon);
        }

        updateUI();
        openShop(); // åˆ·æ–°å•†åº—
    } else {
        alert('ä½ çš„é’±ä¸å¤Ÿå•Šï¼');
    }
}

function closeShop() {
    document.getElementById('shopMenu').style.display = 'none';
    gamePaused = false;
    if (!waveOngoing && currentWave < maxWaves) {
        currentWave++;
        waveTimer = waveDurations[currentWave - 1];
        waveOngoing = true;
    } else if (currentWave >= maxWaves) {
        // æ¸¸æˆç»“æŸåˆ¤æ–­ï¼šä½ ä¹Ÿå¯ä»¥æ”¹æˆBossæˆ˜ç­‰
        alert("æ‰€æœ‰æ³¢æ¬¡å®Œæˆï¼æ¸¸æˆèƒœåˆ©ï¼");
        gameRunning = false;
    }
}

function refreshShop() {
    if (coins >= shopRefreshCost) {
        coins -= shopRefreshCost;
        document.getElementById('playerCoins').textContent = coins;
        openShop(); // é‡æ–°æ‰“å¼€å•†åº—ï¼Œåˆ·æ–°å•†å“
    } else {
        alert("é‡‘å¸ä¸è¶³ï¼Œæ— æ³•åˆ·æ–°ï¼");
    }
}

function updateUI() {
    // æ›´æ–°è¡€æ¡
    // if (!player) return;
    // è®¡ç®—è¡€é‡ç™¾åˆ†æ¯”
    const healthPercent = player.health / player.maxHealth;

    // å–å¾—è¡€æ¡å¡«å……å…ƒç´ å’Œæ–‡å­—
    const healthBarFill = document.getElementById('healthFill');  // âœ… æ–°ID
    const healthText = document.getElementById('healthValue');    // âœ… æ–°ID

    // æ›´æ–°æ ·å¼ä¸æ–‡å­—
    if (healthBarFill) {
        healthBarFill.style.width = `${healthPercent * 100}%`;
    }
    if (healthText) {
        healthText.textContent = `${Math.ceil(player.health)}/${player.maxHealth}`;
    }

    // ====== ç»éªŒæ¡æ›´æ–° ======
    const expPercent = Math.min(1, experience / experienceToLevel);
    const expBarFill = document.getElementById('expFill');
    const expText = document.getElementById('level');  // ä½ æƒ³æ˜¾ç¤ºç­‰çº§çš„åœ°æ–¹

    if (expBarFill) expBarFill.style.width = `${expPercent * 100}%`;
    if (expText) expText.textContent = `${level}`;  // æ˜¾ç¤ºç­‰çº§

    
    document.getElementById('damageBonus').textContent = player.damageBonus;
    document.getElementById('strength').textContent = player.strength;
    document.getElementById('precision').textContent = player.precision;
    document.getElementById('focus').textContent = player.focus;
    document.getElementById('agility').textContent = player.agility;
    document.getElementById('critRate').textContent = player.critRate;
    document.getElementById('attackSpeed').textContent = player.attackSpeed.toFixed(1) + 'x';
    document.getElementById('moveSpeed').textContent = player.baseSpeed.toFixed(1);
    //document.getElementById('level').textContent = level;
    //document.getElementById('kills').textContent = kills;
    //document.getElementById('experience').textContent = experience;
    //document.getElementById('experienceNeeded').textContent = experienceToLevel;
    document.getElementById('coins').textContent = coins;
    document.getElementById('time').textContent = Math.floor(gameTime);
    document.getElementById('wave').textContent = currentWave;
    document.getElementById('waveTime').textContent = waveTimer;


    // âš™ï¸ æ­¦å™¨åˆ—è¡¨ï¼ˆæ‚¬æµ®è¯´æ˜ï¼‰
    const weaponsListEl = document.getElementById('weaponsList');
    const weaponItems = (player.weapons || []).filter(w => w && w.name);
    weaponsListEl.innerHTML = weaponItems.length
    ? weaponItems.map(w => {
        const tip = fmtWeaponTip(w).replace(/"/g,'&quot;'); // æ”¾åœ¨ data-* é‡Œè¦è½¬ä¹‰ "
        return `<div class="weaponItem" data-tip-html="${tip}">â€¢ ${esc(w.name)}</div>`;
        }).join('')
    : '<div style="color:#888">(æš‚æ— æ­¦å™¨)</div>';
    bindTooltipDelegation(weaponsListEl);

    // ğŸº é—ç‰©åˆ—è¡¨ï¼ˆæ˜¾ç¤ºå”¯ä¸€/å å±‚ + æ‚¬æµ®è¯´æ˜ï¼‰
    const relicsList = document.getElementById('relicsList');
    if (relicsList) {
    relicsList.innerHTML = player.relics.length
        ? player.relics.map(r => {
            const stackText = r.stackCount && r.stackCount>1 ? ` Ã—${r.stackCount}` : '';
            const tag = r.category === 'unique' ? ' [å”¯ä¸€]' : '';
            const tip = fmtRelicTip(r).replace(/"/g,'&quot;');
            return `<div class="relicItem" data-tip-html="${tip}">â€¢ ${esc(r.name)}${stackText}${tag}</div>`;
        }).join('')
        : '<div style="color:#888">ï¼ˆæš‚æ— ï¼‰</div>';
    bindTooltipDelegation(relicsList);
    }

}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPoisonZones();
    drawParticles();
    drawCampfires();
    

    drops.forEach(drop => {
        ctx.fillStyle = drop.color;
        ctx.shadowColor = drop.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(drop.x, drop.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });

    bullets.forEach(bullet => {
        if (bullet.type === 'knife') {
            // å°åˆ€ï¼šç”¨ç²¾è‡´çš„åˆ€å½¢ç»˜åˆ¶
            drawKnifeProjectile(bullet);
        } else {
            // å…¶å®ƒå­å¼¹ä»ç„¶ç”»åœ†ç‚¹å…‰çƒ
            ctx.fillStyle = bullet.color;
            ctx.shadowColor = bullet.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    ctx.imageSmoothingQuality = 'low'; // ç¦ç”¨å›¾åƒå¹³æ»‘

    enemies.forEach(enemy => {
        let img = enemyImages[enemy.type];

        if (enemy.frozen) {
            const frozenKey = enemy.type + 'Frozen';
            if (enemyImages[frozenKey] && enemyImages[frozenKey].complete) img = enemyImages[frozenKey];
        }
        
        if (img && img.complete) {
            const size = enemy.radius * 2.5;
            const facingRight = enemy.vx > 0;
            
            // âœ… åˆ›å»ºä¸´æ—¶ç¦»å±ç”»å¸ƒï¼ˆåªåœ¨éœ€è¦ isHit æ—¶æ‰ç”¨ï¼‰
            if (enemy.isHit) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = size;
                tempCanvas.height = size;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = false;
                
                // åœ¨ç¦»å±ç”»å¸ƒç»˜åˆ¶æ•Œäºº
                if (facingRight) {
                    tempCtx.translate(size / 2, size / 2);  // ç§»åˆ°ä¸­å¿ƒ
                    tempCtx.scale(-1, 1);
                    tempCtx.drawImage(img, -size / 2, -size / 2, size, size);
                    
                    // âœ… é®ç½©ä¹Ÿè¦ç›¸å¯¹äºä¸­å¿ƒç”»ï¼ˆå› ä¸ºå·²ç» translate äº†ï¼‰
                    tempCtx.globalCompositeOperation = 'source-atop';
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    tempCtx.fillRect(-size / 2, -size / 2, size, size); // ğŸ”‘ æ”¹è¿™é‡Œï¼
                } else {
                    tempCtx.drawImage(img, 0, 0, size, size);
                    tempCtx.globalCompositeOperation = 'source-atop';
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    tempCtx.fillRect(0, 0, size, size);
                }
                
                ctx.drawImage(tempCanvas, enemy.x - size / 2, enemy.y - size / 2);
            }
            else {
                // æ­£å¸¸ç»˜åˆ¶ï¼ˆæ— é®ç½©ï¼‰
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                if (facingRight) {
                    ctx.translate(enemy.x, enemy.y);
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -size / 2, -size / 2, size, size);
                } else {
                    ctx.drawImage(img, enemy.x - size / 2, enemy.y - size / 2, size, size);
                }
                ctx.restore();
            }
        } else {
            // å¤‡é€‰åœ†å½¢
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = enemy.color;
            ctx.fill();
        }

        // è¡€æ¡
        const barWidth = enemy.radius * 2;
        const barHeight = 4;
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth, barHeight);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth * (enemy.health / enemy.maxHealth), barHeight);
    });


    

    
    player.weapons.forEach(weapon => {
        if (weapon.type === 'melee') {
            const c = weapon.count || 1;
            const base = weapon.baseAngle || 0;  // âœ… ç”¨ updateWeapons é‡Œç®—å¥½çš„ baseAngle
            const step = (Math.PI * 2) / c;
            const rad = weapon.radius ;     // âœ… å…œåº•é»˜è®¤åŠå¾„

            for (let i = 0; i < c; i++) {
                const ang = base + i * step;
                const sx = player.x + Math.cos(ang) * rad;  // âœ… è®¡ç®—å‰‘çš„å®é™…ä½ç½®
                const sy = player.y + Math.sin(ang) * rad;

                if (!Number.isFinite(sx) || !Number.isFinite(sy)) continue;  // âœ… é˜² NaN
                drawSword(sx, sy, ang, weapon);  // âœ… ä¼ åæ ‡å’Œè§’åº¦
            }
        }

        else if (weapon.type === 'floating') {
            const x = player.x + Math.cos(weapon.angle) * weapon.floatingRadius;
            const y = player.y + Math.sin(weapon.angle) * weapon.floatingRadius;
            
            if (weapon.name === 'é—ªç”µçƒ') {
                drawLightningBall(weapon, x, y);
            } else if (weapon.name === 'å†°éœœçƒ') {
                drawFrostBall(weapon, x, y);
            } else if (weapon.name === 'æš—å½±çƒ') {
                drawShadowBall(weapon, x, y);
            }
        }
    });

    drawPlayer(player.x, player.y);
    

    drawDamageNumbers();
}

function gameLoop() {
    if (!gameRunning) return;

    if (!gamePaused) {
        frameCount++;
        // æ›´æ–°æ¯’åœˆ
        updatePoisonZones();

        // å‘¨æœŸæ€§æ¦‚ç‡ç”Ÿæˆç«å †ï¼ˆçº¦æ¯10så°è¯•ä¸€æ¬¡ï¼‰
        if (frameCount % campfireSpawnInterval === 0 && campfires.length <= 3 && Math.random() < campfireSpawnChance) {
            spawnCampfire();
        }

        if (frameCount % 60 === 0) {
            gameTime++;
            enemySpawnRate = Math.max(20, 60 - currentWave * 5); // åˆ·æ€ªç‡
            waveTimer--;

            if (waveOngoing) {
                if (currentWave === 10) {
                    // ç¬¬10æ³¢ï¼šåªçœ‹å€’è®¡æ—¶ï¼Œå€’è®¡æ—¶åˆ°0 â‡’ é€šå…³ï¼ˆæ— è®ºBossæ˜¯å¦å·²è¢«å‡»æ€ï¼‰
                    if (waveTimer <= 0) {
                        victory();        // è§ä¸‹é¢ç¬¬ 4 æ­¥
                        waveOngoing = false;
                    }
                } else {
                    // æ™®é€šæ³¢ï¼šæ—¶é—´åˆ° â‡’ è¿›å•†åº—
                    if (waveTimer <= 0) {
                        waveOngoing = false;
                        clearBattlefield();
                        onWaveEndEffects();
                        openShop();
                    }
                }
            }
        }   
        // â€”â€” åˆ·æ€ªå—ï¼ˆæŒ‰åˆ·æ–°é—´éš”æ‰§è¡Œï¼‰â€”â€”
        if (waveOngoing && frameCount % enemySpawnRate === 0) {
            if (currentWave === 10) {
                // åªç”Ÿæˆä¸€æ¬¡Boss
                if (!bossSpawned) {
                    spawnBoss();
                    bossSpawned = true;
                }
                // â˜… æä½æ¦‚ç‡åˆ·å°æ€ªï¼ˆä½ å¯å¾®è°ƒæ¦‚ç‡/é¢‘ç‡ï¼‰
                if (Math.random() < 0.1) { // çº¦10%å‡ ç‡
                    spawnEnemy();
                }
            } else {
                // æ™®é€šæ³¢ï¼šæˆç¾¤ç”Ÿæˆ
                const enemiesPerSpawn = currentWave >= 5 ? 2 + Math.floor(currentWave / 3) : 1; // æ¯æ¬¡ç”Ÿæˆå‡ ä¸ªæ€ªç‰©
                for (let i = 0; i < enemiesPerSpawn; i++) {
                    spawnEnemy();
                }
            }
        }



        player.vx = 0;
        player.vy = 0;
        if (keys['w'] || keys['arrowup']) player.vy = -player.speed;
        if (keys['s'] || keys['arrowdown']) player.vy = player.speed;
        if (keys['a'] || keys['arrowleft']) player.vx = -player.speed;
        if (keys['d'] || keys['arrowright']) player.vx = player.speed;

        if (player.vx !== 0 && player.vy !== 0) {
            const factor = 1 / Math.sqrt(2);
            player.vx *= factor;
            player.vy *= factor;
        }

        player.x += player.vx;
        player.y += player.vy;

        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

        


        updateWeapons();
        updateBullets();
        updateEnemies();
        updateDrops();
        updateParticles();
        updateDamageNumbers();
        updateUI();
    }

    draw();
    requestAnimationFrame(gameLoop);
}

function togglePause() {
    if (!gameRunning) return;
    gamePaused = !gamePaused;
    
    if (gamePaused) {
        document.getElementById('pauseMenu').style.display = 'block';
    } else {
        document.getElementById('pauseMenu').style.display = 'none';
        document.getElementById('shopMenu').style.display = 'none';
    }
}

function gameOver() {
    gameRunning = false;
    document.getElementById('finalLevel').textContent = level;
    document.getElementById('finalKills').textContent = kills;
    document.getElementById('finalTime').textContent = Math.floor(gameTime);
    document.getElementById('gameOver').style.display = 'block';
}

function victory() {
    alert("ğŸ‰ æ­å–œé€šå…³ï¼ï¼ˆç¬¬10æ³¢å€’è®¡æ—¶ç»“æŸï¼‰");
    gameRunning = false;
}


function restartGame() {
    location.reload();
}

window.onload = () => {
    initHeroMenu();
    updateUI();
};

</script>
</body>
</html>
